# lec 2 - design

- for SQLite, `.schema tableName` will give you the schema for that specific table.

## Normalizing Data

- **Normalizing** means to reduce redundencies, having each entity being its own table, eg author names being their own table.
- Do this by giving each entity their own table, eg riders are their own. stations are their own.

## figuring out associations

- one rider could get ON at one station, and OFF at another.
- one station has many riders
  - you can argue this is a m2m.

<img src="rid1.png" />

## creating tables

- `sqlite mbta.db`
  - prompts you if you want to create a db called mbta.db
- make table for riders, and stations

```sql
CREATE TABLE "riders" (
  "id",
  "name"
);
```

```sql
CREATE TABLE "riders" (
  "id",
  "name",
  "line"
);
```

- typing `.schema` will now reveal the tables

## relating the tables via a junction/join table

- for the m2m relation between riders and stations:

```sql
CREATE TABLE "visits" (
  "rider_id",
  "station_id"
);
```

## data types VS storage classes

### SQLite storage classes:

- NULL
- INTEGER
- REAL
- TEXT
- BLOB (binary large object, usually images or videos)

Each Storage Class has various data types.
For example, integers have...

- 0-byte integer
- 1-byte integer
- 2-byte integer
- 3-byte integer
- 4-byte integer
- 6-byte integer
- 8-byte integer

SQLite will decide by itself which is appropriate to use.

What to do about the `line` field on station? -> TEXT
What about a map.jpg? -> BLOB

What about fares? Here, we have a choice.

- 10 as an integer? Hard to read
- $0.10 as text? But now we can't add/do math with a number...
- 0.10 as a REAL? But there will still be issues with how these numbers are stored with decimals.

## Type Affinities

- in SQLite: associated with individual columns
  - TEXT
  - NUMERIC
  - INTEGER
  - REAL
  - BLOB

if you have `25` and insert it into a column with a text affinity, it inserts it as `"25"`

- conversely, `"10"` inserted into a column with a INT affinity, inserts as `10`

## deleting the table

```sql
DROP TABLE "riders";
DROP TABLE "visits";
DROP TABLE "stations";
```

## Redoing our tables with storage classes

- make a new file called `schema.sql` (also included in this folder)
- it looks like:

```sql
CREATE TABLE "riders" (
  "id" INTEGER,
  "name" TEXT
);
CREATE TABLE "stations" (
  "id" INTEGER,
  "name" TEXT, --Park Street
  "line" TEXT, --Red line
);
CREATE TABLE visits (
  "rider_id" INTEGER,
  "station_id" INTEGER
)
```

### applying the schema.sql create tables to the db

- `sqlite3 mbta.db` (open the database)
- "read in" the file -> `.read schema.sql`
- `.schema` now you can see the tables are there!

<img src="rid2.png" />

#### what about bools?

sqlite doesnt have has bools, you just use ints for 0 or 1

## Table Constraints

- you can apply a constraint to the entire table. A constraint is when a value has to be a certain 'way'
  - eg primary keys must be unique, and in our case, integers
    `PRIMARY KEY` AND `FOREIGN KEY` are two constraints we can apply. Using these We now have...

### Primary Key Constraint

In the table created, AFTER ALL the cols, the constraint is applied like so:

```sql
CREATE TABLE "riders" (
  "id" INTEGER,
  "name" TEXT,
  PRIMARY KEY("id")
);
```

### Foreign Key Constraint

Looks similar to how PK is applied, but just saying `FOREIGN KEY("rider_id")` is not enough.

- We need to tell it the table (and col in that table) it `REFERENCES`s

```sql
FOREIGN KEY("other_id") REFERENCES "tableName"("columnName")
```

```sql
CREATE TABLE visits (
  "rider_id" INTEGER,
  "station_id" INTEGER,
  -- the PK for visits is auto-generated by sqlite, it is not explicitly typed here.
  -- because rider_id and station_id both reference PKs on other tables, they are BOTH foreign keys.
  FOREIGN KEY("rider_id") REFERENCES "riders"("id"), -- REFERENCES "tableName"("columnName")
  FOREIGN KEY("station_id") REFERENCES "stations"("id")
);
```

## Column Constraints

We can also apply constraints on columns:

- CHECK
  - check to be sure (some expression) such as, is greater than 0.
- DEFAULT
  - if a value is not supplied when a new row is inserted, insert this for the default value.
- NOT NULL
- UNIQUE

These are keywords that are given on the same line as the column declaration, such as:

```sql
  "email" TEXT UNIQUE NOT NULL,
```

- Note: once you apply the PRIMARY KEY constraint, this requires the pk to be not null, so there is no need to put things like NOT NULL on the "id" col.
- Same goes for the Foreign keys constraints.

## Re-assessing our schema

- the subway system doesnt actually keep track of people as riders, but instead "Charlie Cards", like a metrocard.
- We can now make a erd like this:

<img src="card1.png" />
Where....
  - a *card* can make many, or even 0, *swipes*.
  - a single *swipe* belongs to one and ONLY one *card*.
  - And:
  - a *station* can have many, or even 0, *swipes* that occur at it.
  - a single *swipe* belongs to one and ONLY one *station*.

And with columns...
<img src="card2.png" />

## Altering our tables

- all of these are entered in the sqlite terminal

### dropping the riders table

`DROP TABLE "riders";`

### renaming tables & columns

- `ALTER TABLE ...` ok now what do we want to do?...
  - `RENAME TABLE "table1" TO "table2"`
  - `ADD COLUMN columnName DATATYPE`
  - `RENAME COLUMN ... TO ...`
  - `DROP COLUMN columnName`

Q: We need the "visits" table to be "swipes" table ->
A: `ALTER TABLE "visits" RENAME TO "swipes";`

Q: We want to add a `type` column (for entering, exiting, adding funds etc...)
A: `ALTER TABLE "swipes" ADD COLUMN "ttpe" TEXT;`

Q: Oops we typo'd. How to change that column name?
A: `ALTER TABLE "swipes" RENAME COLUMN "ttpe" TO "type";`

Q: How would I drop the column?
A: `ALTER TABLE "swipes" DROP COLUMN "type";`

## redoing our schema in the .sql file

### default time of now

- Our swipes has a col called datetime, which is a timestamp.
- By default we want it to be now, which we can use:

```sql
  "datetime" NUMERIC NOT NULL DEFAULT CURRENT_TIMESTAMP,
```

### check

- we want the amount, or transaction fee to be either a positive or negative amt, never 0.
  - so we can write a check like so:

```sql
  "amount" NUMERIC NOT NULL CHECK("amount" != 0),
```

- the 'type' of transaction should only one `IN` some specific strings, so we can write:

```sql
  "type" TEXT NOT NULL CHECK("type" IN ('enter', 'exit', 'deposit')),
```
